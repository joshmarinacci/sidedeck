<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My Excellent Presentation</title>
    <script src="node_modules/pubnub/dist/web/pubnub.min.js"></script>
    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/solarized-light.min.css">
    <link rel="stylesheet" href="styles/styles.css">
    <script src="scripts/highlight.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="scripts/utils.js" type="application/javascript"></script>
    <script src="scripts/code.js" type="application/javascript"></script>
    <script src="node_modules/hammerjs/hammer.js" type="application/javascript"></script>
</head>
<body>

<footer>
        <span>josh@pubnub.com</span>
        <span class="grow"></span>
        <span style="letter-spacing: 1px; font-size: 120%;"><b>Serverless Chatbots</b></span>
        <span class="grow"></span>
        <span>PubNub</span>
        <button id="questions-show">Questions</button>
    </footer>

<!-- intro -->
<section class="split-v">
      <div>
          <h1>Josh Marinacci</h1>
          <h2>Head of Developer Evangelism</h2>
      </div>
      <div>
          <img src="images/pubnub.png"/>
      </div>

    <aside>
      I'm the head of developer evangelism at PubNub.
      At PubNub we run a Data Stream Network. It lets people
      conduct realtime communication with extremely high security
      and extremely low latency.  We have a lot of customers doing
      cutting edge things, so this gives me an inside seat at what
      is coming next. And one of those things is chatbots.
    </aside>
</section>
<!-- what are chatbots -->
<section>
    <h1>Serverless Chatbots</h1>
    [image of a chatbot]
    <aside>
        <p>So what are chatbots? At first you might think it's a little program
            which you interact with through text. And that's true.  Many if not
            most are text driven, but not all.  Chat bots can use voice too.</p>
    </aside>
</section>
<!--- Amazon Alexa -->
<section>
    <img src="images/Amazon-Echo-Blog_quotes_2-01.png">
    <aside>
        like amazon alexa. It's essentially a complex set of chatbots using
        voice recognition. And these things are going to continue to evolve.
        It won't be just voice. Some chatbots will have images, and video,
        and maybe more.
    </aside>
</section>
<!--- AR/VR --->
<section>
    <img src="images/augmented_reality_1.jpg"/>
    <aside>
        <p>Perhaps we'll have assistants in virtual reality and augmented reality.
        I don't know what this visualization is showing. I don't think I'd want
        barcharts so close to my eyes.</p>

        <p>But i can tell you about a real example. We sponosred a hackathon
        a few months ago and one of the teams made a chatbot which used photos of
        sign language to convert into text then speech, in realtime. One day a system like this will be built into our phones or whatever VR/AR thing comes after phones.</p>
    </aside>
</section>
<!--  the common thread of chatbots --->
<section>
    <h1>AI + network = Chatbot</h1>
    <aside>
        So we're going to see a lot of crazy things over the next
        few years that will have nothing to do with text, but could
        still be consider a chatbot. These all have a common thread.
        They will all combine AI with the network. So to build one of
        these we need these ingredients.</aside>
</section>
<!-- requirements for ChatBots -->
<section>
    <h2>Your requirements</h2>
    <ul>
        <li>Domain Knowledge</li>
        <li>Artificial Intelligence</li>
        <li>Realtime Infrastructure</li>
    </ul>
    <aside>
        <p>First you need your domain knowledge. This is the knowledge bout what your bot is actually doing. If it's a bot for news then it's the news sources. If it's a bot for ordering pizza then it's knowledge about the store locations and pizza ingredients. It's whatever your bot does.</p>
        <p>Next you'll need some level of Artificial Intelligence. Some chatbots need full natural language processing. some need a backend end with a rich neural net. Some just need a glorified phone tree. Maybe just some if statements. It really depends on what you are doing.</p>
        <p>When you make a chatbot you also need some sort of realtime infrastructure.  A chatbot involves constant communication between the end user and your bot, possibly with other platform proxies in the way, and possibly with other webservices which provide the knowledge or AI that the chatbot needs. So you need some realtime infrastructure to tie all this together with very low latency and high security. This infrastructure is what ties everything together.</p>
    </aside>
</section>
<!-- requirements, not focus --->
<section>
    <h2>Your requirements, not your focus</h2>
    <ul>
        <li>Domain Knowledge</li>
        <li>Artificial Intelligence</li>
        <li>Realtime Infrastructure</li>
    </ul>
    <aside>But here's the thing. These second two features <b>are</b> your requirements but they <b>are not</b> your focus.  Imagine you are building a physical robot. Electricity is a requirement, but it's not your focus. You aren't going to invent a new battery or a new charger circuit. That's not the problem you are actually trying to solve. It's the same with chatbots. The bot's infrastructure and AI are required but they are not your focus. Only the Domain Knowledge is your focus.
    </aside>
</section>
<!-- don't build your own infrastructure or AI -->
<section>
    <h2>Don't build your own infrastructure</h2>
    <h2>Don't build your own AI</h2>
    <h2>Focus on your domain knowledge</h2>
    <aside>
        So please, if you remember nothing else from this talk I want you to remember
        this slide.
    </aside>
</section>

<!--
    <section>
        <img src="images/PushChat-2-Chat.jpg">
        <aside>
            In the future chatbots will continue to evolve. they will be able to handle
            more tasks. they won't be limited to chat. they might not be in a chat
            interface, but voice extensions of your home voice bot.
        </aside>
    </section>
--->

<!--- demo time --->
<section>
    <h1>Demo Time</h1>
    <aside>
        So that's enough high level stuff. Let's look at a simple chatbot.
    </aside>
</section>



<!--- emojibot demo --->
<section>
    <h1>EmojiBot</h1>
    <iframe
            style="border: 1px solid orange; width:80vw; height:70vh;"
            src="heartbot.html"
    ></iframe>
    <aside>This is the EmojiBot. It fixes what you type in by making it heartier.
    </aside>
</section>



<!-- emojibot code --->
<section>
    <h2>HeartBot Code</h2>
    <pre class="code javascript">
export default (request) => {
    var txt = request.message.text;
    txt = txt.replace(/poop/g,"\uD83D\uDCA9");
    txt = txt.replace(/crap/g,"\uD83D\uDCA9");
    txt = txt.replace(/love/g,"\uD83D\uDE0D");
    txt = txt.replace(/heart/g,"\uD83D\uDC9C");
    txt = txt.replace(/sad/g,"\uD83D\uDE1E");
    txt = txt.replace(/happy/g,"\uD83D\uDE04");

    request.message.text = "Your message isn't hearty enough!"
        +" There I fixed it: &lt;br/&gt;"
        + txt;
    return request.ok(); // Return a promise when you're done
}
</pre>

    <aside>
        now lets dive into some code. this is what makes the emoji bot work.
        This is my AI. now, I'm using AI loosely here. It's just a search and replace.
        So the code is simple. What's more interesting is where does this code run.
    </aside>

</section>


<!-- Emoji bot diagram -->
<section>
    <img src="images/EmojiDiagram.png"/>
    <aside>
        <p>The code runs in the realtime infrastructure. I'm using PubNub and BLOCKS.
            PubNub is realtime as a service. You publish a message to a channel.  You subscribe to a channel. pubnub moves the messages around, anwyehere in the world in 250ms.
        </p>
        <p>
            [code for publish a message and subscribe]
        </p>

        <p>PubNub BLOCKS runs JS on the edge. What does that mean? As the message moves through the network code you write is executed on those messages. Where is the code run? It doesn't matter. It's always run in the part of the network closest to where the users are.</p>
    </aside>
</section>

<!-- serverless !== no servers -->
<section>
    <h1>Serverless !== No Servers</h1>
    <aside>
        <p>This is serverless. Severless does not mean that there's no servers.
        Obviously the code is running somwehere.</p>

        <p>Serverless means coding at the level of a function or object, not the level of an application or server. We don't care about where it's hosted, what's the underlying OS. We just write code that responds to a request. push a button and it's deployed worldwide instantly. have 10 ten users? it works perfect. suddenly you get 10000 users? it still works. no code changes. serverless infrastructure is secure and scalable.</p>

        <p>BTW: PubNub's free tier is free forever. 1 million messages a month. Unless you are going into production with an product, you'll never go through this quota.</p>

    </aside>
</section>



<!-- cloudinary --->
<section>
    <h1>Cloudinary</h1>
    <aside>
        <p>So that was the Emoji Bot. Let's look at something more complicated. Something that does something useful.</p>

        <p>There's this cool company called Cloudinary. They make an image manipulation service. It's mainly meant for resizing and adjusting images for your blog. But with a little clever work I built a chatbot that manipulates images for you.
        </p>
    </aside>
</section>

<!-- image bot demo -->
<section>
    <h1>ImageBot</h1>
    <iframe
            style="border: 1px solid orange; width:90vw; height:70vh;"
            src="../../cloudinary-react-demo/build/index.html"
    ></iframe>
    <aside>
        <ul>
            <li>please reset the image</li>
            <li>please show the image</li>
            <li>upload image</li>
            <li>please set the width to 500px</li>
            <li>please auto-contrast and auto-sharpen</li>
            <li>please make it square</li>
            <li>please overlay acmelogo at the south west corner</li>
        </ul>
        <p>now the really cool thing about this is that it's a group chat.
        multiple people can collaborate on it at once. each giving
        commands to the bot to adjust the image until the group likes
        what it sees. And it will scale no matter how many users we have.
        </p>
    </aside>
</section>

<!-- image bot diagram -->
<section>
    <h2>ImageBot Architecture</h2>
    <img src="images/CloudinaryDiagram.png"/>
    <aside>
        Here is the image bot. This one doesn't use a full NLP solution,
        just some code I put together that looks for commands after
        the trigger word 'please'.
    </aside>
</section>

<!-- image bot NLP -->
<section>
    <h2>ImageBot NLP</h2>
    <pre class="code javascript">
var words = text.split(" ")
    .map((w)=>w.toLowerCase())
    .filter((w)=>{
        if(w === 'the')return false;
        if(w === 'it') return false;
        if(w === 'to') return false;
        if(w === 'at') return false;
        if(w === 'in') return false;
        return true;
    });
console.log("words",words);
if(!words.includes("please")) return false;

var n = words.findIndex((w) => w === 'please');
var verb = words[n+1];
if(verb === 'upload') return upload(words);
if(verb === 'display') return display(rest);
if(verb === 'show') return show(rest);
if(verb === 'resize') return resize(rest);
if(verb === 'reset') return reset(rest);
if(verb === 'make' &amp;&amp; nextWord === 'square') return makeSquare(rest);
...
    </pre>
<pre class="javascript code">
    {
        "action":"resize"
    }
</pre>
    <aside>
        When the user types in a message, it comes to the block. the block
    sends it to a stateless webservice I wrote which turns the text into
    a command, or returns false if it didn't see the stopwords.
        The final result is a command. something like "action:resize";
    </aside>
</section>

<!-- calling cloudinary -->
<section>
    <h2>ImageBot Cloudinary Service Calls</h2>
<pre class="javascript code">
return db.get('context').then((context) => {
    if(!context) context = {};
    var command = request.message;
    if(command.action === 'resize') context.width = command.size;
    if(command.action === 'crop') {
        context.crop = true;
        context.shape = 'square';
        context.gravity = command.gravity;
    }

    //generate the final url
    let apiUrl = 'http://res.cloudinary.com/' +
        cloudName + '/' + resource + '/' + operation + '/';
    apiUrl += filename  + '.' + context.format;

    //save the url
    request.message.cloudinaryURL = apiUrl;


    db.set('context',context); //save the context
    return request.ok(); // Return the final message
});

</pre>
    <aside>
        <p>The second part of the code uses the action to generate
        a custom Cloudinary URL and finishes the publish.
            All of this happens in the split second between
            the time the user sent their message to the network
            and when it was forwarded on to the destination.
            </p>

        <p>It doesn't matter how many people are listening
        to this channel. They will all be able to interact with the bot
        and see what the other is doing just by listening to the same channel.
            </p>

        <p>If they want their own conversation then they can just use different
            channels. it's all the same code.</p>

        <p>Notice in this code that the settings are stored in a context
        object which is saved and loaded from the network. This is very important
        because if different people are in different parts of the network their
        action will be run by different instances of the code. het network
        has a key value store which can save objects and sync them between nodes
        so no matter where you are the context state will be at the node
        closest to you.</p>

    </aside>
</section>


<!-- don't write your own AI -->

<section>
    <h1>ImageBot lesson</h1>
    <h2>Don't built your own NLP</h2>
    <aside>
        <p>So the reason I showed you this demo is to convince you not to do what
        I did. When I started this project I thought, it's not real nlp. It's
        just some keyword recognition. As I added more and more features the
        code grew and grew and became harder to understand.</p>
        <p>in particular using a rules based approach like i did gets harder
        to manage the precedence of the rules. As you add more features
        the existing features become more fragile. This approach won't
        scale.</p>
        <p>The solution is don't build youur own AI. There are existing NLP
        solutions that can easily handle this. So that brings me
        to my next demo.</p>
    </aside>
</section>




<!-- mrrockbot demo -->
<section>
    <iframe
            style="border: 1px solid orange; width:90vw; height:90vh;"
            src="http://localhost/pubnub/chatbot-webinar/chat.html"
    ></iframe>
    <aside>This is my favorite one. MR ROCKBOT is a chat bot who understands
        only rock related facts and really terrible rock jokes.
        let's try it out.


        This is a chat app with a knowledge base of facts from wikipedia
        and gifs from giphy. It also uses IBM Watson to process questions
        as well as translate from french to english.

        ask tell me a joke in french.
        i'm sure it's hilarious if I spoke french.
    </aside>
</section>

<!-- what is serverless -->
<!--
<section>
    <h1>What is <i>Serverless</i> anyway?</h1>

    <ul>
        <li>functions, not apps or servers</li>
        <li>in the network, near the user, (like CDN)</li>
        <li>acts as a single computer</li>
        <li>talk to 3rd party micro-services</li>
        <li>infinitely scalable</li>
    </ul>

    <aside>
        <p>these were all built with a <i>serverless platform</i>
            this is a serverless platform, not a cloud provider. the different
            is that you aren't provisioining a server, even a virtual one.
            there is no administration. you are working at the level of functions
            that you put into the network.</p>

        <p>also, you aren't
            just switching one providers cloud server for another. this code runs in the network.
            it's more like a CDN. the message goes from the phone to some place on the
            edge. it goes to whatever part of the network is closest to the end user.
        </p>

        <p>of course there are real servers somewhere, but
            it's serverless because there isn't one server or even a
            group of servers.  underneath
            is computing infrastructure around the globe acting as a single unit, always
            putting computation as close as possible to the end user for the lowest
            latency and greatest security.
        </p>

        <p>
            the serverless provider then talks to an service for the AI. it may
            also talk to other services for other parts of the chatbot. the important
            thing is that provider in the middle has the controlling computation and stores
            all the state. Each of these providers are simple microservices that do one thing
            well and are as stateless as possible, making them easier to build and more reliable.
        </p>


        <p>
            Further more, as your chatbot becomes more popular
            which we hope it well, you don't have to worry about scaling. the infrastructure
            scales for you. Most of the providers in this space have usage based pricing so
            your costs only go up when your revenue does. No cliffs to worry about. Scaling
            becomes a non-issue, so you can focus on what you are trying to actually do.
        </p>

    </aside>

</section>
-->


<!-- mr rockbot diagram -->
<section>
    <h2>MR ROCKBOT Architecture</h2>
    <img src="images/WatsonDiagram.png"/>
    <aside>
        <p>So Mr Rockbot has a similar architecture. A message goes to the network compute block, which calls a series of IBM and wikipedia services to calculate the final    answer. In this case I'm using IBM's Alchemy API for language translation and the Conversation API for the natural language part, which is far more effective than
        the hand written code I did for the previous demo. </p>
        </aside>
</section>

<!-- language detection API -->
<section>
    <h2>IBM Watson Text Alchemy API</h2>
    <img src="images/alchemy-api-090915-14-638.jpg"/>
    <aside>
    <p>Mr rockbot is the most complicated because he uses several services.
        IBM has an amazing set of APIs under the Watson group.
        The first thing I did was use the language detection and translation
        APIs.
        </p>
    </aside>
</section>

<!-- detect language -->
<section>
    <h2>Detect Language and Translate</h2>
    <pre class="code javascript">
const query_params = {
    outputMode:'json',
    apikey:'494a8df6f920d85b1de4a8172c21dbc264d6446f',
    extract:'keywords,relations,language',
    maxRetrieve: 1,
    text:request.message.text
};
var url = "http://gateway-a.watsonplatform.net/calls/text/TextGetCombinedData?"
        +query.stringify(query_params);

return xhr.fetch(url).then((x)=>{
    var ret = JSON.parse(x.body);
    if(ret.language != 'english') {
        return translateMessage(request.message, ret.language);
    }
    return cookMessage(ret);
});
</pre>
    <aside>
        Here's the code. It first calls the language detection API to see if it's in english
        or french. If it's in english then it sends it to the next stage of the pipeline. If it's
        not in english then calls translate message which does another webservice call.
    </aside>
</section>

<!-- watson text alchemy api --->
<section>
    <h2>IBM Watson Text Alchemy API</h2>
    <img src="images/alchemy-api-090915-14-638.jpg"/>
    <aside>
    <p>The next part is processing the conversation now that everything is in english. In my original version I used IBM Alchemy language API to look at the input text. it pulls out entities and intents. Unfortunately this API is really meant for looking at larger documents, not tiny snippets of text.  </p>
    </aside>
</section>

<!-- watson conversations api -->
<section>
    <h2>IBM Watson Conversations</h2>
    <img src="images/Dialog-ProcessFlow.jpg"/>
    <aside>
        However, IBM recently introduced a new api specifically for conversational
        interactions called, appropriately enough: Conversations. It was originally
        called the Dialog Service, so you might see some tutorials with that name.
        With Conversations you actually train the system by giving it examples
        of the kinds of things you are looking for.
    </aside>
</section>

<!-- create intents -->
<section>
    <img src="images/watson-intents.png">
    <aside>
        First you create 'intents.' These are the things the user could ask the chatbot to do for it. For example, if this was a home automation bot you might use an intent like 'turn on'. For this bot the intents were things like tell me a joke, tell me your favorite something, what is something. roughly these are your verbs.
    </aside>
</section>

<!-- create entities -->
<section>
    <img src="images/watson-entities.png">
    <aside>
        Next you create entities. These are things the user could ask about, or are the
        target of an intent. For example: in a home automation bot you might
        use an entity like 'lights' or 'door'. You can also specify synonyms
        so that it can recognize many forms of the request. For this bot I used
        things like music and food, so you can ask 'what is your favorite music'.
        Think of these like nouns that the chatbot can understand.
    </aside>
</section>

<!-- create dialogs -->
<section>
    <img src="images/watson-dialog.png">
    <aside>
        Finally you can create dialogs. These are workflows that the user
        can go through. This lets you specify what the bot actually
        says to the end user in different circumstances. If you arlready
        have a knowledgebase of facts and responses then you can skip this part
        and just use the intents and entities.
    </aside>
</section>

<!-- use conversations -->
<section>
    <h2>Use Conversations API</h2>
<pre class="code javascript">
var url = creds.url+'/v1/workspaces/'+creds.workspaceID+'/message?version=2016-09-20';

var payload = { input: {  text: request.message.text   } }

return kvstore.get("context").then((ctx) => {
    if(ctx) payload.context = ctx;

    const http_options = { method:'POST', body: JSON.stringify(payload) }

    return xhr.fetch(url, http_options).then((x)=>{
        var body = JSON.parse(x.body);
        return kvstore.set("context",body.context).then(()=>{
            request.message.text = body.output.text[0];
            request.message.watson = body;
            return request.ok();
        });
    }).catch((e)=>{
        console.log("ERROR");
        return request.ok();
    });
});

</pre>
    <aside>
        <p>After you teach Watson about your problem domain you can call it from your serverless code using a simple HTTP POST. It's important to note that Conversations is a stateless API. In order to understand the context of a conversation you have to provide  this context on each request using a context structure.</p>

        <p>I'm storing this in PubNub BLOCKS, our serverless platform. But remember that this code will always be run on the edge nearest to the end user, and that user might move. So I store this context in our Key Value store which is eventually consistent. If the user moves to another part of the network the context will follow them.</p>
    </aside>
</section>




<section>
    <h1>Bonus!</h1>
    <h2>Realtime isn't just for text</h2>
</section>


<section>
    <h2>Don't build your own AI</h2>
    <h2>Don't build your own realtime infrastructure.</h2>
    <ul>
        <li>Cloudinary</li>
        <li>IBM Watson</li>
        <li>PubNub</li>
    </ul>
    <h3>@joshmarinacci</h3>
    <h3>josh@pubnub.com</h3>
    <aside>
        Today I've shown you how to build three different chatbots using
        serverless infrastructure and AI services. At no point did I have
        to spin up a server or write multi-threaded code. That's the magic of serverless.
        I also didn't have to have a PhD in Machine Learning to build these.
        That's the magic of AI services.
        So please. Don't make your own realtime service or AI. Focus on the
        problem you are trying to solve, not infrastructure.
        Thank you.
    </aside>
</section>



    <div id="speaker-view" class="hbox">
        <div class="vbox grow">
            <div class="grow panel">currnet slide</div>
            <div class="grow panel">next slide</div>
        </div>
        <div class="vbox grow">
            <div class="grow panel" id="speaker-notes">my notes</div>
            <div class="grow panel" id="speaker-questions">questions</div>
        </div>
    </div>

    <div id="questions-panel" class="vbox">
        <div class="grow scroll" id="questions-view-wrapper">
            <div id="questions-view"></div>
        </div>
        <div id="questions-ask" class="hbox">
            <input  id="question-field" type="text" class="grow">
            <button id="question-button">send</button>
        </div>
    </div>

<div id="speaker-notes-control" class="vbox">
    <button id="to-start">to start</button>
    <button id="to-left">to left</button>
    <button id="to-right">to right</button>
    <button id="to-end">to end</button>
</div>


<script type="text/javascript">
    //highlight the page with code in it
    function style() {
        var elems = document.querySelectorAll('.javascript');
        elems.forEach(function(elem){
            hljs.highlightBlock(elem);
        })
    }
     setTimeout(style,1000);


    try {
        document.querySelectorAll("section").forEach(function(sec,i) {
            /*
            var hammertime = new Hammer(sec);
            hammertime.on('tap', function(ev) {
                slides.navRight();
            });
            hammertime.on('swiperight', function (ev) {
                slides.navLeft();
            });
            hammertime.on('swipeleft', function (ev) {
                slides.navRight();
            });*/
        })
    } catch (e) {
        console.log(e);
    }

</script>

</body>
</html>


<!--
scratch notes


fix style of the common header
fix style of code snippets
background of iframes should be white
redesign alignment.

vbox fills it, centering everything horizontlly and vertically. gravity to center.
if too small then start shrinking them. same weight given to all for extra space.





who am i. pubnub. lots of customers.

what are chatbots. not just chat.
it's an ai that you interact with via text
but soon you'll interact with voice
and images
so instead of AI driven chatbots this should be AI driven Assistants
it's always about some software which helps you accomplish some goal.

so these things have three requirements to build.
    some level of AI
    realtime infrastructure
    domain knowledge

if you remember only one thing from this talk, don't build your own
realtime infrastructure and ai. just bring your domain knowledge. the rest can
be bought.



let me show you a simple chat bot

heart bot demo

simple.  here's how it works.

diagram of heart bot

serverless infrastructure hosting my AI. I'm using AI loosely here. just some
simple code. no neural nets.

my AI: heartbot code.

realtime infrastructure. i need something to host this somewhere. I'm using PubNub and BLOCKS.

PubNub is realtime as a service. You publish a message to a channel.  You subscribe to a channel. pubnub moves the messages around, anwyehere in the world in 250ms.
[code for publish a message and subscribe]

PubNub BLOCKS runs JS on the edge. What does that mean? As the message moves through the network code you write is executed on those messages. Where is the code run? It doesn't matter. It's always run in the part of the network closest to where the users are.

This is serverless. coding at the level of a function or object, not the level of an application or server. don't care about where it's hosted, what's the underlying OS. write code that responds to a request. push a button and it's deployed worldwide instantly. have 10 ten users? it works perfect. suddenly you get 10000 users? it still works. no code changes. serverless infrastructure is secure and scalable.

BTW: PubNub's free tier is free forever. 1 million messages a month. Unless you are going into production with an product, you'll never go through this quota.


so my heartbot archtecture looks like this [diagram]


now this app isn't really AI per say, but it is a bot that chats with you. let's try something more complex.

this is the image bot. he's a bit smarter. he can actually manipulate images








--->
