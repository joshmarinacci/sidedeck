<html>
<body>
<section>
</section>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My Excellent Presentation</title>
    <script src="node_modules/pubnub/dist/web/pubnub.min.js"></script>
    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/solarized-light.min.css">
    <link rel="stylesheet" href="styles/styles.css">
    <script src="scripts/highlight.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="scripts/utils.js" type="application/javascript"></script>
    <script src="scripts/code.js" type="application/javascript"></script>
    <script src="node_modules/hammerjs/hammer.js" type="application/javascript"></script>
</head>
<body>

    <footer>
        <span>@joshmarinacci</span>
        <span class="grow"></span>
        <span>ES6: The Good Parts</span>
        <span class="grow"></span>
        <span>PubNub</span>
        <button id="questions-show">Questions</button>
    </footer>

    <section>
        <h1>My presentation</h1>
        <h2>this is some cool stuff</h2>
        <aside>
            these are some speaker notes
        </aside>
    </section>


    <section>
        <h1>Welcome</h1>
        <h3>Josh, Head of Dev Rel</h3>
        <h3>josh@pubnub.com</h3>
        <aside>
            * Welcome
                * I'm josh head of developer relations at PubNub.
                talk about ES6 today.
                please use the questions panel.
        </aside>
    </section>

    <section>
        <h1>What is ES6?</h1>

        <ul>
            <li>EcmaScript 6</li>
            <li>EcmaScript 2015</li>
            <li>ES 2015</li>
            <li>The new stuff</li>
        </ul>

        <aside>
                * JavaScript has had many versions over the years, but overall the evolution was slow. More changes have happened in the past two years than in the previous twenty.
                * ES 6 stands for EcmaScript 6. It's also called EcmaScript 2015, or ES 2015.  These are all different names for the 'new Javascript'.
                * I'm not entirely sure *why* JS has changed so much recently, but it seems to be because the owners of the major JavaScript engines have finally become interested in pushing the language forward. Also, the advent of transpilers have made it possible to use new language features *before* they are built into the browsers. I'll talk a bit more about transpilers in a moment.
        </aside>
    </section>

    <section>
        <h1>Why ES6 matters</h1>
        <aside>
        * JS matters because it's the fabric of the web, and increasingly used for server side apps with Node, and mobile and desktop apps with Cordova, React Native, and Electron. In short: JS is everywhere. So it matters that we push it forward. Languages which don't evolve start to die.
        * The other reason to make JS better is simply that it's awesome if JS gets better. our code can improve. our apps can have fewer bugs. And some of these features enable the runtimes to actually run code faster.
        </aside>
    </section>

    <section>
        <h1>Why is PubNub Teaching ES6</h1>
        <ul>
            <li>Core feature of BLOCKS</li>
            <li>Fabric of the Web, desktop, mobile and more</li>
        </ul>
        <aside>
        <p>we use JS heavily in our new product BLOCKS. many of the features
        are key to making BLOCKS a good product.</p>
        <p>second, also it's part of the fabric of the web and one of our most used
        languages. We care that our customers can be effective while using it.</p>
    </section>

    <section>
        <h1>Too much new</h1>
        <h3>Let's be useful instead</h3>
        <aside>
            <p>So ES6 is awesome. So many cool new things. That's the problem. Waaay
            too many cool new things. Some are more valuable than others. Some are
            more ready than others. it’s confusing, too many things in different
            states of readiness.</p>
            <p>So that's why I created this class. To show you the four features of
                ES6 that are both useful and ready to use now.
                Some of the others will be ready at some point,
                but you can ignore them for now. We are just going to talk about what you can use today.
            </p>
        </aside>
    </section>

    <section>
        <h1>Four good parts</h1>
        <ul>
            <li>better vars</li>
            <li>better strings</li>
            <li>better functions</li>
            <li>better async</li>
            <li>ignore the rest</li>
        </ul>
    </section>

    <section>
        <h1>The Problems with Variables</h1>
        <aside>
            * normally when you want to create a variable you use the 'var' keyword.
            'var' is great, but it has a couple of problems.
        </aside>

    </section>

    <section>
        <h2>Variables always vary</h2>
        <pre class='javascript code'>
var VARS = {
    foo
        set = function() { }
        get = function() { return 42 }
}
VARS.foo = 42; // now I have a constant
        </pre>
        <aside>
            first, var is always variable. there is no way to make a constant. if
            you really want a constant you have to create a property of an
            object and override the setter so that it can't be set.
        </aside>
    </section>

    <section>
        <h2>Function Scoping</h2>
        <pre>
function badCode() {
    if(foo) {
        var bar = 5;
    }
    if(bar) {
        console.log(bar);
    }
}
        </pre>
        <aside>
        * another problem is that vars are global to the function they are
        defined in, not the block. you'd think that the log
        statement wouldn't work because
        <b>bar</b> is defined in a different block.
        and in a language like java or C# you'd be right, but in
        js var is global to a function, not a block.
        </aside>
    </section>

    <section>
        <h2>Hoisting</h2>
        <pre>
function badCode() {
    console.log("foo is",foo);
    var foo = 'bar';
}
        </pre>
        <aside>
            another problem is that variables are hoisted.
            look at this code.  i'm using foo before i've even defined it.
            what does this code even mean?  under the hood the javascript
            engine will hoist the variable declaration to the top of the
            function.  i can sort of see why you might want to hoist
            functions, but variable hoisting makes it very easy to introduce subtle bugs.
        </aside>
    </section>

    <section>
        <h2>Hoisting</h2>
        <pre>
for(var i=0; i&lt;5; i++) {
    console.log(i);
}
console.log(i);
        </pre>
        <aside>
        look at this code with a for loop.
        the variable is only used inside the loop, but i can still
        reference it outside. this is just bugs waiting to happen.
        </aside>
    </section>

    <section>
        <h2>A better way</h2>
        <h1><code>const</code> and <code>let</code></h1>
        <aside>
            the good news is we don't have to use var anymore. instead we can use const and let.
        </aside>
    </section>

    <section>
        <h1><code>const</code></h1>
        <pre class='javascript'>
function test() {
    const foo = 'bar';
    foo = 'baz'; //error
}
        </pre>
        <aside>
            * const does exactly what you the name suggests. it makes a real
            constant. if you try to set the constant you'll get an error.
            even better, code linting systems can detect this kind of bug at
            compile time now, so you can find bugs earlier at development
            time rather than in production.
        </aside>
    </section>

    <section>
        <h1><code>let</code></h1>
        <pre>
function goodCode() {
    if(foo) {
        let bar = 5;
    }
    if(bar) {
        console.log(bar); //error
    }
}        </pre>
        <aside>
            let is just like var, it's a way to create variables, but it's
            scoped by block instead of function. now it does what we expect.
        </aside>
    </section>

    <section>
        <h1><code>let</code></h1>
        <pre>
function goodCode() {
    for(let i=0; i&lt;5; i++) {
        console.log(i);
    }
    console.log(i); //error
}        </pre>
        <aside>
            look at this for loop, now the i variable is restricted to the
            for loop. there is no way it can be used outside accidentally.
            also, let isn't hoisted, so all of those magic moving variables
            go away.
        </aside>
    </section>

    <section>
        <h1>Super Strings</h1>
        <pre>
var q  = 'foo';
var qq = "foo";

var bq = `foo`;

var qq = "Sally sells \"sea shells\"";
var bq = `Sally sells "sea shells"`;        </pre>
        <aside>
            <p>javascript es6 introduces a new type of string. you use it just
            like a regular string, but instead of using single or double quotes,
            you use the back quote.</p>
            <p>so far so good, but nothing is different.
            it does have an advantage of when you need to use double or
            single quotes inside of a string you don't need to escape them anymore.
            but this new string does some other stuff too.</p>
        </aside>
    </section>

    <section>
        <h1>Multi-line Strings</h1>
        <pre>
var qq = "this is a very long"
    + " piece of text that goes over several lines"
    + " and would require silly hacks";

var bq = `this is a very long
    piece of text that goes over several lines
    and would require silly hacks`;
        </pre>
        <aside>We finally have mulit-line strings.
            need to quote several lines of something? you don't have to
            escape newlines or do join tricks anymore. just put in the newlines
            directly and it works.
        </aside>
    </section>

    <section>
        <h1>Template Strings</h1>
        <pre>
var name = "Alice";
var greeting = `Good morning ${name}`;
var amount = 5;
var price = 3;
var sales = `That costs ${amount*price} dollars`;        </pre>
        <aside>
            multiline support makes it great for doing templates.
            which is where another new feature comes in, expression escaping.
            within a super string you can put ${} and anything inside the brackets
            can be any javascript expression. this is much cleaner than
            double escaping your quotes, and it makes templates easier to
            build.
        </aside>
    </section>
    <section>
        <h1>HTML Templates</h1>
        <pre>
var template = `
  &lt;div&gt;
      &lt;h3&gt;Good morning ${name}&lt;/h3&gt;
      &lt;p&gt;
          That item will cost you
          &lt;b&gt;${amount*price}&lt;/b&gt;
          dollars.
      &lt;/p&gt;
  &lt;/div&gt;
`
        </pre>
        <aside>
            here's a more complex example
        </aside>
    </section>


    <section>
        <h1>Arrow Functions</h1>
        <aside>
            * arrow functions are a different syntax for regular
            functions. they let you write the same code in a more
            compact way, along with one very important difference.
            the 'this' variable means something different. lets' look at some code.
        </aside>
    </section>

    <section>
        <h2>Good</h2>
        <pre>
var output = [];
for(var i=0; i&lt;input.length; i++) {
    output[i] = input[i] * 2;
}
        </pre>
        <aside>
            * suppose you want to loop over an array to double the values within it,
            producing a new array. you could do it this way with a for loop,
            but that creates extra variables and it can be easy to accidentially
            break early or get the index wrong. plus it's a lot of extra typing.
        </aside>
    </section>

    <section>
        <h2>Better</h2>
        <pre>
var output = input.map(function(x) {
    return x * 2;
});
        </pre>
        <aside>
            Javascript arrays have a function called map which calls a
            function on every element to generate a new element,
            which are then placed into a new array.
            still, it would be nice to make it smaller.
            the x*2 part is the only thing which actually does any work.
            the rest is syntactic overhead.
            instead we can do it with an arrow function like this
        </aside>
    </section>

    <section>
        <h2>Best</h2>
        <pre>
var output = input.map((x)=>x*2);
        </pre>
        <aside>
            let me explain what's happening.
        </aside>
    </section>

    <section>
        <h1>Arrow Functions</h1>
        <pre>
function (x) {
    return x * 2;
}        </pre>
        <pre>
(x) => {
    return x * 2;
}        </pre>
        <aside>
            arrow functions let us write the same thing smaller.
        </aside>
    </section>

    <section>
        <h1>Arrow Functions</h1>
        <pre>
(x) => { return x * 2; }</pre>
        <aside>
            but we can make it even shorter. let's remove the whitespace. that's better [code].
        </aside>
    </section>

    <section>
        <h1>Arrow Functions</h1>
        <pre>
(x) => x * 2</pre>
<pre>
var output = input.map((x)=>x*2);
</pre>
        <aside>
            but we can make it even shorter. we can remove the return and the
            braces and semicolon, then we get a tiny one line expression
            which automatically returns it's value. that's so much cleaner.
        </aside>
    </section>

    <section>
        <h1>The curse of <code>this</code></h1>
        <pre>
            function App() {
                this.clicked = false;

                var button = document.getElementById('button');
                button.addEventListener('click', function(evt) {
                    this.clicked = true; //won't do what you think
                });
            }
        </pre>
        <aside>
            in javascript the magic variable 'this' always refers to the object
            that the function is called on. so code like this doesn't do what you
            think it does. when you are using other objects the context may be
            different. when you pass a function to somewhere else to be called back,
            it may call the function with a different 'this'. when you add event
            handlers to a button the button will be the 'this'.
            which isn't what we want.
        </aside>
    </section>

    <section>
        <h1>The <code>self</code> pattern</h1>
        <pre>
            function App() {
                this.clicked = false;

                var button = document.getElementById('button');

                var self = this;
                button.addEventListener('click', function(evt) {
                    self.clicked = true;
                });
            }
        </pre>
        <aside>
            this created something known as the 'self' pattern where you save
            the correct `this` using a temp variable called `self`;
            kinda yucky. here's another way to solve it.
        </aside>
    </section>

    <section>
        <h1>Function binding</h1>
        <pre>
            function App() {
                this.clicked = false;

                var button = document.getElementById('button');

                var callback = (function(evt) {
                    this.clicked = true
                }).bind(this);

                button.addEventListener('click',callback);
            }
        </pre>
        <aside>
            another way to solve it is to bind the function.
            'bind' forces the 'this' to be a specific object.
        </aside>
    </section>

    <section>
        <pre>
            function App() {
                this.clicked = false;

                var button = document.getElementById('button');
                button.addEventListener('click',()=>{
                    this.clicked = true;
                });
            }
        </pre>
        <aside>
            arrow functions give us a better way to do it.
            they automatically capture the `this` var from the surrounding
            context of where the funciton <b>is defined</b>, not where it's <b>used</b>.
            this means you can pass the function to some other place and know the
            right version of this will be used.  here's the same code with an arrow
            funciton, and now it does what you think it should do.
        </aside>
    </section>

    <section>
        <h1>Arrow Functions are Awesome</h1>
        <aside>
            arrow functions are really awesome. i try to use them
            everywhere i can. they make 'this' sensible again.
        </aside>
    </section>

    <section>
        <h1>Promises for Long Running Work</h1>
        <aside>
             another great feature of arrow functions is that they work well
             with promises. a promise is a new kind of object in javascript
             designed to help with things that take a long time.
             javascript doesn't have threads. if you want to do something that
             might take a long time then you have to use callbacks.
        </aside>
    </section>
    <section>
        <h1>Pyramid of Doom</h1>
        <pre>
            fs.readFile("file.txt", function(err, file) {
                db.fetchNames(function(err, names) {
                    processFile(file, names, function(err, outfile) {
                        fs.writeFile('file.txt',outfile, function(err, status) {
                            console.log("we are done writing the file");
                        })
                    });
                })
            });
        </pre>
        <aside>
            for example, in node you might want to load a file, parse it,
            make a database request, then write a new file. these must all be
            done in order, but they are all asynchronous so you have to start
            nesting your callbacks. this produces what js hackers like to
            call the pyramid of doom. massively nested code.
            it's ugly, hard to reason about, and has lots of nasty corners
            for bugs to hide.  promises help us fight this.
        </aside>
    </section>
    <section>
        <h1>What is a promise</h1>
        <aside>
            a promise is an object that represents a value which may not be
            available yet. it 'promises' to have the value in the uture.
            you can add a callback to be invoked when the final value is ready.
            like this[code].
        </aside>
    </section>


        * in this way it's much like traditional callbacks, but promises add a twist. they can be chained.  let's revisit our code from before. each of these functions must be called in order, and each depends on the result of the previous one. using promises we can do it like this instead. notice how the arrow functions make this nice and clean [code]. each then callback returns a value. this value is passed to the next one. so all of our functions can be easily chained
        * now consider what happens if one of these things fails?  if the first one fails we could put in a try catch block, but the next then will still be called. really we want everything to stop if the first one fails. promises have anotehr trick up their sleeves: the catch callback.
        * [code] in this version if anything fails it will immediately jump to the catch callback, skipping the rest.  after the catch we can still add more then clauses.
        * promises only work if the apis we call actually use them. fortunately lots of libraries are starting to switch over to promises, but while we wait we can make our own promises two.  you do this with the promise constructor.
        * [code] it takes two values: resovle and reject. each of these are callback functions.  inside you do whatever you need to that takes a long time, even if it involves multiple callbacks.  when you are completely done invoke resolve() with the final value. this will then be sent the the first 'then' clause of whatever uses your promise.  if something bad happens and you want to reject the value, instead of throwing an error use reject() and you can pass whatever alternate value you want.
        * here's a real-life example. i use AJAX calls all the time but they can be ugly. let's wrap up this code in a promise. [code]
        * now it looks like this [code]. still the same basic code, but i can call it like this instead [code]. wow, that's so much cleaner.
        * In reality I don't need to wrap up my AJAX calls because there is a new web standard called Fetch which already does this for me [fetch code example].
        * now suppose you have multiple promises which don't depend on eachother, and you want to know when *all* of them are done. for example, if you have a list of file names and you want to load each file and be notified when they are all done. we can do that with Promise.all() this is a utlity method which takes an array of promises and returns a new promise that resolves when all of the subpromises complete. [code]
        * so promises can be a bit tricky to wrap your head around at first, but once you start using them i think you'll really like them. it makes it very easy to pull multiple functions together into a single workflow that makes logical sense.
    * bonus: and of course the many array and object functions.
        * so that is the four awesome features of ES6, the new javascript, that you can start using right now.  However, i really want to give you a nice bonus feature. There's a bunch of functions which aren't exactly new, but what is new is that we can finally use them because they are supported everywhere.
        * Array has a bunch of awesome utility functions which work great with promises. YOu'll never need to write a loop again.
            * map, forEach, find, filter, indexOf
        * For working with hashmaps and other objects, the Object API has some useful functions too. Object.keys [code, others?]
* things to definitely avoid for now
    * destructuring. this lets you pull values out of an object by name. it can be useful in a few situation, but the best use i've found is extracting functions from modules. unfortunately modules are still a mess and don't work the same everywhere, so avoid for now. along with destructuring you can do tricks like default parameters, and the spread operator. I find these to be more trouble than they are worth, at least for now.
    * There's a bunch of other things coming in ES6 that are genuinely useful, but they aren't supported everywhere yet so I suggest you hold off for a while. These include symbols, generators, iterators, weak maps and sets, and proxies
    * There is also a new class syntax. It still uses JavaScript's prototypical inheritance, but it makes the syntax of defining a class cleaner [code, before and after]. However, it's not as valuable without the new module support so I suggest waiting a bit longer.
* how to use these extensions in server side node
    * use the recent node. it just works. [verify]
* how to use these extensions in client side node
    * most desktop browsers and mobile browsers support these.  depending on your audience you may have older browsers / older mobile OSes that don’t.  [make a chart] whenever you want to know if something is ready, go to caniuse.com
* Code for the future.
    * in the past we would say: wait until x% of the user audience can support this. Today, we say: code for the future and let a compiler worry about the past. simplest way to use babel or web pack. mention kits for different frameworks.
    * using these in your code will make your code better and prepare for the future. as tools and browsers mature you won’t need to change your code. just one day you’ll be able to drop the compiler step. (of course you’ll still want to use minimizers and compressors and linters anyway).
* So that is 4 awesome new features of ES6 that you can start using right away. More stuff is coming, but you don't need to wait to use these. get to codin'. and now we have time for some questions.




    <section>
        <h1>code sample</h1>
        <pre class='javascript'>
            some cool awesome code
        </pre>
    </section>


    <div id="speaker-view" class="hbox">
        <div class="vbox grow">
            <div class="grow panel">currnet slide</div>
            <div class="grow panel">next slide</div>
        </div>
        <div class="vbox grow">
            <div class="grow panel" id="speaker-notes">my notes</div>
            <div class="grow panel" id="speaker-questions">questions</div>
        </div>
    </div>

    <div id="questions-panel" class="vbox">
        <div class="grow scroll" id="questions-view-wrapper">
            <div id="questions-view"></div>
        </div>
        <div id="questions-ask" class="hbox">
            <input  id="question-field" type="text" class="grow">
            <button id="question-button">send</button>
        </div>
    </div>

    <div id="speaker-notes-control" class="vbox">
        <button id="to-start">to start</button>
        <button id="to-left">to left</button>
        <button id="to-right">to right</button>
        <button id="to-end">to end</button>
    </div>


    <script type="text/javascript">
        //highlight the page with code in it
        function style() {
            var elems = document.querySelectorAll('pre');
            elems.forEach(function(elem){
                try {
                    hljs.highlightBlock(elem);
                } catch(e) {
                    console.log("error highlighting",e);
                }
            })
        }
         setTimeout(style,1000);


        try {
            document.querySelectorAll("section").forEach(function(sec,i) {
                var hammertime = new Hammer(sec);
                hammertime.on('tap', function(ev) {
                    slides.navRight();
                });
                hammertime.on('swiperight', function (ev) {
                    slides.navLeft();
                });
                hammertime.on('swipeleft', function (ev) {
                    slides.navRight();
                });
            })
        } catch (e) {
            console.log(e);
        }

    </script>
</body>
</html>
