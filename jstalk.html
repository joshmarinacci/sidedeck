<html>
<body>
<section>
</section>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My Excellent Presentation</title>
    <script src="node_modules/pubnub/dist/web/pubnub.min.js"></script>
    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/solarized-light.min.css">
    <link rel="stylesheet" href="styles/styles.css">
    <script src="scripts/highlight.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="scripts/utils.js" type="application/javascript"></script>
    <script src="scripts/code.js" type="application/javascript"></script>
    <script src="node_modules/hammerjs/hammer.js" type="application/javascript"></script>
</head>
<body>

    <footer>
        <span>@joshmarinacci</span>
        <span class="grow"></span>
        <span>ES6: The Good Parts</span>
        <span class="grow"></span>
        <span>PubNub</span>
        <button id="questions-show">Questions</button>
    </footer>

    <section>
        <h1>ES6: The Good Parts</h1>
        <h2>josh@pubnub.com</h2>
        <h2>Head of Dev Rel</h2>
        <aside>
            * Welcome
                * I'm josh head of developer relations at PubNub.
                talk about ES6 today.
                please use the questions panel.
        </aside>
    </section>

    <section>
        <h1>What is ES6?</h1>

        <ul>
            <li>EcmaScript 6</li>
            <li>EcmaScript 2015</li>
            <li>ES 2015</li>
            <li>The new stuff</li>
        </ul>

        <aside>
                * JavaScript has had many versions over the years, but overall
                the evolution was slow until recently. More changes have happened in the past
                two years than in the previous twenty.
                * ES 6 stands for EcmaScript 6. It's also called EcmaScript 2015,
                or ES 2015.  These are all different names for the 'new Javascript'.
                * I'm not entirely sure *why* JS has changed so much recently,
                but it seems to be because the owners of the major JavaScript engines
                have finally become interested in pushing the language forward.
                Also, the advent of transpilers have made it possible to use new
                language features *before* they are built into the browsers.
                I'll talk a bit more about transpilers in a moment.
        </aside>
    </section>

    <section>
        <h1>Why ES6 matters</h1>
        <aside>
        JS matters because it's the fabric of the web, and increasingly used
        for server side apps with Node, and mobile and desktop apps with Cordova,
        React Native, and Electron. In short: JS is everywhere. So it matters
        that we push it forward. Languages which don't evolve start to die.
        The other reason to make JS better is simply that it's awesome if JS
        gets better. Our code can improve. our apps can have fewer bugs. And
        some of these features enable the runtimes to actually run code faster.
        </aside>
    </section>

    <section>
        <h1>Why is PubNub Teaching ES6</h1>
        <ul>
            <li>Core feature of BLOCKS</li>
            <li>Fabric of the Web, desktop, mobile and more</li>
        </ul>
        <aside>
        <p>we use JS heavily in our new product BLOCKS. many of the features
        are key to making BLOCKS a good product.</p>
        <p>second, also it's part of the fabric of the web and one of our most used
        languages. We care that our customers can be effective while using it.</p>
    </section>

    <section>
        <h1>Too much new</h1>
        <h3>Let's be useful instead</h3>
        <aside>
            <p>So ES6 is awesome. So many cool new things. That's the problem. Waaay
            too many cool new things. Some are more valuable than others. Some are
            more ready than others. itâ€™s confusing, too many things in different
            states of readiness.</p>
            <p>So that's why I created this class. To show you the four features of
                ES6 that are both useful and ready to use now.
                Some of the others will be ready at some point,
                but you can ignore them for now. We are just going to talk about what you can use today.
            </p>
        </aside>
    </section>

    <section>
        <h1>Four good parts</h1>
        <ul>
            <li>better vars</li>
            <li>better strings</li>
            <li>better functions</li>
            <li>better async</li>
            <li>ignore the rest</li>
        </ul>
    </section>

    <section>
        <h1>The Problems with Variables</h1>
        <aside>
            * normally when you want to create a variable you use the 'var' keyword.
            'var' is great, but it has a couple of problems.
        </aside>

    </section>

    <section>
        <h2>Variables always vary</h2>
        <pre class='javascript code'>
var VARS = {
    foo
        set = function() { }
        get = function() { return 42 }
}
VARS.foo = 42; // now I have a constant
        </pre>
        <aside>
            first, var is always variable. there is no way to make a constant. if
            you really want a constant you have to create a property of an
            object and override the setter so that it can't be set.
        </aside>
    </section>

    <section>
        <h2>Function Scoping</h2>
        <pre>
function badCode() {
    if(foo) {
        var x = 5;
    }
    if(bar) {
        console.log(x);
    }
}
        </pre>
        <aside>
        * another problem is that vars are global to the function they are
        defined in, not the block. you'd think that the log
        statement wouldn't work because
        <b>bar</b> is defined in a different block.
        and in a language like java or C# you'd be right, but in
        js var is global to a function, not a block.
        </aside>
    </section>

    <section>
        <h2>Hoisting</h2>
        <pre>
function badCode() {
    console.log("foo is",foo);
    var foo = 'bar';
}
        </pre>
        <aside>
            another problem is that variables are hoisted.
            look at this code.  i'm using foo before i've even defined it.
            what does this code even mean?  under the hood the javascript
            engine will hoist the variable declaration to the top of the
            function.  i can sort of see why you might want to hoist
            functions, but variable hoisting makes it very easy to introduce subtle bugs.
        </aside>
    </section>

    <section>
        <h2>Hoisting</h2>
        <pre>
for(var i=0; i&lt;5; i++) {
    console.log(i);
}
console.log(i);
        </pre>
        <aside>
        look at this code with a for loop.
        the variable is only used inside the loop, but i can still
        reference it outside. this is just bugs waiting to happen.
        </aside>
    </section>

    <section>
        <h2>A better way</h2>
        <h1><code>const</code> and <code>let</code></h1>
        <aside>
            the good news is we don't have to use var anymore. instead we can use const and let.
        </aside>
    </section>

    <section>
        <h1><code>const</code></h1>
        <pre class='javascript'>function test() {
    const foo = 'bar';
    foo = 'baz'; //error
}</pre>
        <aside>
            <b>const</b> does exactly what the name suggests. It makes a real
            constant. If you try to set the constant you'll get an error.
            even better, code linting systems can detect this kind of bug at
            compile time now, so you can find bugs earlier at development
            time rather than in production.
        </aside>
    </section>

    <section>
        <h1><code>let</code></h1>
        <pre>function goodCode() {
    if(foo) {
        let x = 5;
    }
    if(bar) {
        console.log(x); //error
    }
}        </pre>
        <aside>
            <b>let</b> is just like <b>var</b>, it's a way to create variables, but it's
            scoped by block instead of function. now it does what we expect.
        </aside>
    </section>

    <section>
        <h1><code>let</code></h1>
        <pre>function goodCode() {
    for(let i=0; i&lt;5; i++) {
        console.log(i);
    }
    console.log(i); //error
}</pre>
        <aside>
            Look at this <b>for</b> loop, now the <b>i</b> variable is restricted to the
            <b>for</b> loop. there is no way it can be used outside accidentally.
            Also, <b>let</b> isn't hoisted, so all of those magic moving variables
            go away.
        </aside>
    </section>

    <section>
        <h1>Template Literals: Super Strings</h1>
        <pre>var q  = 'foo';
var qq = "foo";

var bq = `foo`;

var qq = "Sally sells \"sea shells\"";
var bq = `Sally sells "sea shells"`;</pre>
        <aside>
            <p>ES6 introduces a new type of string called Template Literals. I
                prefer to call them super strings. You use it just
            like a regular string, but instead of using single or double quotes,
            you use the back quote.</p>
            <p>So far so good, but nothing is very different.
            It does have an advantage of when you need to use double or
            single quotes inside of a string you don't need to escape them anymore.
            but this new string does some other stuff too.</p>
        </aside>
    </section>

    <section>
        <h1>Multi-line Strings</h1>
        <pre>var qq = "this is a very long"
    + " piece of text that goes over several lines"
    + " and would require silly hacks";

var bq = `this is a very long
    piece of text that goes over several lines
    and would require silly hacks`;</pre>
        <aside>We finally have mulit-line strings.
            Need to quote several lines of something? You don't have to
            escape newlines or do join tricks anymore. Just put in the newlines
            directly and it works.</aside>
    </section>

    <section>
        <h1>Template Strings</h1>
        <pre>var name = "Alice";
var greeting = `Good morning ${name}`;
var amount = 5;
var price = 3;
var sales = `That costs ${amount*price} dollars`;</pre>
        <aside>
            Multiline support makes it great for doing templates.
            Which is where another new feature comes in, expression escaping.
            Within a super string you can put <b>${}</b> and anything inside the brackets
            can be any Javascript expression. This is much cleaner than
            double escaping your quotes, and it makes templates easier to
            build.
        </aside>
    </section>
    <section>
        <h1>HTML Templates</h1>
        <pre>var template = `
  &lt;div&gt;
      &lt;h3&gt;Good morning ${name}&lt;/h3&gt;
      &lt;p&gt;
          That item will cost you
          &lt;b&gt;${amount*price}&lt;/b&gt;
          dollars.
      &lt;/p&gt;
  &lt;/div&gt;
`</pre>
        <aside>
            Here's a more complex example.
        </aside>
    </section>


    <section>
        <h1>Arrow Functions</h1>
        <aside>
            Arrow functions are a different syntax for regular
            functions. they let you write the same code in a more
            compact way, along with one very important difference.
            the 'this' variable means something different. lets' look at some code.
        </aside>
    </section>

    <section>
        <h2>Good</h2>
        <pre>var output = [];
for(var i=0; i&lt;input.length; i++) {
    output[i] = input[i] * 2;
}</pre>
        <aside>
            suppose you want to loop over an array to double the values within it,
            producing a new array. you could do it this way with a for loop,
            but that creates extra variables and it can be easy to accidentially
            break early or get the index wrong. plus it's a lot of extra typing.
        </aside>
    </section>

    <section>
        <h2>Better</h2>
        <pre>var output = input.map(function(x) {
    return x * 2;
});</pre>
        <aside>
            Javascript arrays have a function called map which calls a
            function on every element to generate a new element,
            which are then placed into a new array.
            still, it would be nice to make it smaller.
            the x*2 part is the only thing which actually does any work.
            the rest is syntactic overhead.
            instead we can do it with an arrow function like this
        </aside>
    </section>

    <section>
        <h2>Best</h2>
        <pre>var output = input.map((x)=>x*2);</pre>
        <aside>
            let me explain what's happening.
        </aside>
    </section>

    <section>
        <h1>Arrow Functions</h1>
        <pre>function (x) {
    return x * 2;
}</pre>
        <pre>(x) => {
    return x * 2;
}</pre>
        <aside>
            arrow functions let us write the same thing smaller.
        </aside>
    </section>

    <section>
        <h1>Arrow Functions</h1>
        <pre>(x) => { return x * 2; }</pre>
        <aside>
            but we can make it even shorter. let's remove the whitespace. that's better [code].
        </aside>
    </section>

    <section>
        <h1>Arrow Functions</h1>
        <pre>(x) => x * 2</pre>
        <pre>var output = input.map((x)=>x*2);</pre>
        <aside>
            But we can make it even shorter. We can remove the return and the
            braces and semicolon, then we get a tiny one line expression
            which automatically returns it's value. that's so much cleaner.
        </aside>
    </section>

    <section>
        <h1>The curse of <code>this</code></h1>
        <pre>function App() {
    this.clicked = false;

    var button = document.getElementById('button');
    button.addEventListener('click', function(evt) {
        this.clicked = true; //won't do what you think
    });
}</pre>
        <aside>
            In Javascript the magic variable 'this' always refers to the object
            that the function is called on. so code like this doesn't do what you
            think it does. when you are using other objects the context may be
            different. when you pass a function to somewhere else to be called back,
            it may call the function with a different 'this'. when you add event
            handlers to a button the button will be the 'this'.
            which isn't what we want.
        </aside>
    </section>

    <section>
        <h1>The <code>self</code> pattern</h1>
        <pre>function App() {
    this.clicked = false;

    var button = document.getElementById('button');

    <b>var self = this;</b>
    button.addEventListener('click', function(evt) {
        self.clicked = true;
    });
}</pre>
        <aside>
            this created something known as the 'self' pattern where you save
            the correct `this` using a temp variable called `self`;
            kinda yucky. here's another way to solve it.
        </aside>
    </section>

    <section>
        <h1>Function binding</h1>
        <pre>function App() {
    this.clicked = false;

    var button = document.getElementById('button');

    var callback = (function(evt) {
        this.clicked = true
    })<b>.bind(this);</b>

    button.addEventListener('click',callback);
}</pre>
        <aside>
            another way to solve it is to bind the function.
            'bind' forces the 'this' to be a specific object.
        </aside>
    </section>

    <section>
        <pre>function App() {
    this.clicked = false;

    var button = document.getElementById('button');
    button.addEventListener('click',()=>{
        this.clicked = true;
    });
}</pre>
        <aside>
            Arrow functions give us a better way to do it.
            they automatically capture the `this` var from the surrounding
            context of where the funciton <b>is defined</b>, not where it's <b>used</b>.
            this means you can pass the function to some other place and know the
            right version of this will be used.  here's the same code with an arrow
            funciton, and now it does what you think it should do.
        </aside>
    </section>

    <section>
        <h1>Arrow Functions are Awesome</h1>
        <aside>
            arrow functions are really awesome. i try to use them
            everywhere i can. they make 'this' sensible again.
        </aside>
    </section>

    <section>
        <h1>Promises for Long Running Work</h1>
        <aside>
             another great feature of arrow functions is that they work well
             with promises. a promise is a new kind of object in javascript
             designed to help with things that take a long time.
             javascript doesn't have threads. if you want to do something that
             might take a long time then you have to use callbacks.
        </aside>
    </section>
    <section>
        <h1>Pyramid of Doom</h1>
        <pre>fs.readFile("file.txt", function(err, file) {
    db.fetchNames(function(err, names) {
        processFile(file, names, function(err, outfile) {
            fs.writeFile('file.txt',outfile, function(err, status) {
                console.log("we are done writing the file");
            })
        });
    })
});</pre>
        <aside>
            For example, in Node you might want to load a file, parse it,
            make a database request, then write a new file. these must all be
            done in order, but they are all asynchronous so you have to start
            nesting your callbacks. this produces what js hackers like to
            call the pyramid of doom. massively nested code.
            it's ugly, hard to reason about, and has lots of nasty corners
            for bugs to hide.  promises help us fight this.
        </aside>
    </section>
    <section>
        <h1>What is a promise</h1>
        <pre>
            var prom = makeSomePromise();
            //value not ready yet
            prom.then((value)=>{
                //do something with the value
            })
        </pre>
        <aside>
            A <code>Promise</code> is an object that represents a value which may not be
            available yet. It 'promises' to have the value in the future.
            You can add a callback to be invoked when the final value is ready.
            like this.
        </aside>
    </section>

    <section>
        <pre>
    fs.readFile("file.txt")
        .then((file) => {
            return db.fetchNames().then((names)=>{
                return processFile(file,names)
            })
        })
        .then((outfile)=>{
            return fs.writeFile('file.txt',outfile);
        })
        .then(()=>{
            console.log("we are done writing the file");
        });
</pre>

        <aside>
            <p>In this way it's much like traditional callbacks, but promises add a
            twist. they can be <i>chained</i>.  Let's revisit our code from before.
            Each of these functions must be called in order, and each depends on
            the result of the previous one. Using promises we can do it like this
            instead. Notice how the arrow functions make this nice and clean.
            Each <code>then()</code> callback returns a value.
            This value is passed to the next one so all of our functions can be easily chained.</p>

            <p>Now you'll notice that the processFile command needs the result of the previous
            two values. but a promise only passes one value. We also don't care what
            order readFile and fetchNames happens in. We just want to know when both
            are completed. We can do that with Promise.all</p>
        </aside>
    </section>

    <section>
        <pre>
            var proms = filenames.map((name)=> readFile(name));
            Promise.all(proms).then((files)=>{
                console.log(`we have ${files.length} files`);
            });
        </pre>
        <aside>If we had a list of filenames we wanted
            to load each file and be notified when they are all done.
            we can do that with Promise.all() this is a utlity method which
            takes an array of promises and returns a new promise that
            resolves when all of the subpromises complete.
            Lets look at our previous example again.
        </aside>
    </section>

    <section>
        <pre>
            Promise.all([
                fs.readFile("file.txt"),
                db.fetchNames()
            ])
            .then((vals) => processFile(vals[0],vals[1]))
            .then((outfile)=> fs.writeFile('file.txt',outfile))
            .then(()=> console.log("we are done writing the file"));
        </pre>

        <aside>
            <p>I'm combining the read file and database call into a single promise
                using Promise.all. The resulting value is an array containing
                the results of both, so I can put them into processFile.
                I've also used the abbreviated arrow syntax to make
                the code smaller and cleaner</p>

            <p>now consider what happens if one of these things fails?  if
                the first one fails we could put in a try catch block, but
                the next then will still be called. really we want everything
                to stop if the first one fails. promises have another trick up
                their sleeves: the catch callback.</p>
        </aside>
    </section>

    <section>
        <pre>
            Promise.all([
                fs.readFile("file.txt"),
                db.fetchNames()
            ])
            .then((vals) => processFile(vals[0],vals[1]))
            .then((outfile)=> fs.writeFile('file.txt',outfile))
            .then(()=> console.log("we are done writing the file"))
            <b>.catch((e) => {
                console.log("some error happened");
            });</b>
        </pre>
        <aside>
            In this version if anything fails it will immediately jump to the
            catch callback a the end, skipping the rest.  after the catch we
            can still add more then clauses.
        </aside>
    </section>



    <section>
        <pre>
            function makePromise(foo,bar) {
                return new Promise((resolve, reject) => {
                    try {
                        //do long stuff
                        resolve(value);
                    } catch {
                        reject(error);
                    }
                });
            }
        </pre>
        <aside>
            <p>Of promises only work if the apis we call actually use them.
            Fortunately lots of libraries are starting to switch over to
            promises, but while we wait we can make our own promises too.
            We do it with the promise constructor.</p>

            <p>It takes two values: resolve and reject. each of these are
                callback functions. Inside you do whatever you need to that
                takes a long time, even if it involves multiple callbacks.
                When you are completely done invoke resolve() with the final
                value. this will then be sent the the first 'then' cl
                ause of whatever uses your promise.</p>

            <p>if something bad happens and you want to reject the value,
                instead of throwing an error use reject() and you can pass
                whatever alternate value you want.
            </p>
        </aside>
    </section>

    <section>
        <pre>
var url = "http://api.silly.io/api/list/e3da7b3b-976d-4de1-a743-e0124ce973b8?format=json";

var xml = new XMLHttpRequest();
xml.addEventListener('load', function() {
    var result = JSON.parse(this.responseText);
    console.log(result);
});
xml.open("GET",url);
xml.send();
</pre>

        <aside>Here's a real-life example.
            I use AJAX calls all the time but they can be ugly, like this.
            Let's wrap this code up in a promise.
        </aside>
    </section>

    <section>
        <pre>function doGet(url) {
    return new Promise((resolve,rej)=>{
        var xml = new XMLHttpRequest();
        xml.addEventListener('load', function() {
            var result = JSON.parse(this.responseText);
            resolve(result);
        });
        xml.addEventListener('error',function(error) {
            reject(error);
        });
        xml.open("GET",url);
        xml.send();
    });
}</pre>
<pre>
var url = "http://api.silly.io/api/list/e3da7b3b-976d-4de1-a743-e0124ce973b8?format=json";
doGet(url).then((obj)=>{
    console.log(obj);
});
</pre>

    <aside>now it looks like this. It's still the same basic code, but i can call it like this instead.
        wow, that's so much cleaner.
    </aside>
    </section>

    <section>
        <pre>var url = "http://api.silly.io/api/list/e3da7b3b-976d-4de1-a743-e0124ce973b8?format=json";
fetch(url).then((obj) => {
    console.log(obj);
});
</pre>
        <aside>
        In reality I don't need to wrap up my AJAX calls because there is a new
        web standard called Fetch which already does this for me, but
        until Fetch is supported in all browser, we can use our own.
        </aside>
    </section>

    <section>
        <h1>Promises are awesome</h1>
        <aside>so promises can be a bit tricky to wrap your head around at
            first, but once you start using them I think you'll really like
            them. It makes it very easy to pull multiple functions together
            into a single workflow that makes logical sense, and to
            properly catch all errors along the way.</aside>
    </section>

    <section>
        <h1>Bonus Features</h1>
        <aside>
            So that is the four awesome features of ES6 that you can start using right now.
            However, I really want to give you a nice bonus feature. There's a bunch
            of functions which aren't exactly new, in fact they've been around for
            a while, but we can finally use them because they are supported everywhere.
        </aside>
    </section>

    <section>
        <h1>Array</h1>
        <pre>
            var values = [1,2,3,4,5,6,7,8,9,10];

            values.forEach((x)=>console.log(x));
            var doubled = values.map((x) => x*2);

            //find all values that match the filter
            var evens = values.filter((x)=>x%2==0);

            //true if at least one item matches
            var any = values.some((x) => x > 10);

            //find the first that matches
            var six = values.find((x) =>  x >= 6);
            //find the index of the first that match
            var index = values.findIndex((x) =>  x >= 6);
            //reduce the array to a single value
            var sum = values.reduce((a,b) => a+b, 0);
        </pre>


        <aside>Array has a bunch of awesome utility functions which work great with arrow functions. You'll never need to write a loop again.
        </aside>
    </section>

    <section>
        <pre>
            var obj = {
                first:'Alice',
                middle:'N',
                last:'Wonderland',
                age:8,
                height:45,
            }
            Object.keys(obj).forEach((key)=>{
                console.log("key = ", key);
                console.log("value = ", obj[key]);
            });
        </pre>
        <aside>For working with hashmaps and other objects, the Object API has some useful functions too. Object.keys will give
            you a list of every property name on an object, in a predictable order. I use this all the time.
        </aside>
    </section>

    <section>
        <h1>Things to definitely avoid for now</h1>
        <ul>
            <li>Destructuring</li>
            <li>Modules</li>
            <li>Default Parameters</li>
            <li>Spread Operator</li>
        </ul>
        <aside>
        <p>Destructuring. This lets you pull values out of an object by name.
        it can be useful in a few situation, but the best use i've found is
        extracting functions from modules. Unfortunately modules are still a
        mess and don't work the same everywhere, so avoid for now. </p>
        <p>Along with destructuring you can do without tricks like default
            parameters, and the spread operator. I find these to be more
            trouble than they are worth, at least for now.</p>
        </aside>
    </section>

    <section>
        <h1>Things to definitely avoid for now</h1>
        <ul>
            <li>Symbols</li>
            <li>Generators and Iterators</li>
            <li>Weak Maps and Weak Sets</li>
            <li>Proxies</li>
        </ul>
        <aside>
            There's a bunch of other things coming in ES6 that are genuinely
            useful, but they aren't supported everywhere yet so I suggest you
            hold off for a while. These include symbols, generators, iterators,
            weak maps and sets, and proxies
        </aside>
    </aside>
</section>

<section>
    <h1>Class Syntax</h1>
    <pre>class Foo extends Bar {
    constructor(stuff) {
        super(stuff);
        this.first = "first name"
    }
    doStuff() {
    }
    doMoreStuff() {
    }
}</pre>
    <aside>
    There is also a new class syntax. It still uses JavaScript's prototypical
    inheritance, but it makes the syntax of defining a class cleaner.
    However, it's not as valuable without the
    new module support so I suggest waiting a bit longer.
    </aside>
</section>

<section>
    <h2>Can I Use them now</h2>

    <h1><a href="http://caniuse.com/">caniuse.com</a></h1>

    <aside>
        Most desktop and mobile browsers support everything I've shown you.
        However, depending on your audience you may have older
        browsers / older mobile OSes that donâ€™t.  Whenever you want to know
        if something is ready, go to caniuse.com. It will tell you
        what versions of each browser support what.
    </aside>
</section>

<!--
<section>
* Code for the future.
    * in the past we would say: wait until x% of the user audience can support this. Today, we say: code for the future and let a compiler worry about the past. simplest way to use babel or web pack. mention kits for different frameworks.
    * using these in your code will make your code better and prepare for the future. as tools and browsers mature you wonâ€™t need to change your code. just one day youâ€™ll be able to drop the compiler step. (of course youâ€™ll still want to use minimizers and compressors and linters anyway).
</section>
-->

<section>
    <h2>Learn More</h2>

    <h1><a href="https://www.pubnub.com/blocks-catalog/">pubnub.com/blocks-catalog</a></h1>
    <aside>So that is 4 awesome new features of ES6 that you can start
        using right away. More stuff is coming, but you don't need to wait to
        use these. get to codin'. and now we have time for some questions.
    </aside>
</section>





    <div id="speaker-view" class="hbox">
        <div class="vbox grow">
            <div class="grow panel">currnet slide</div>
            <div class="grow panel">next slide</div>
        </div>
        <div class="vbox grow">
            <div class="grow panel" id="speaker-notes">my notes</div>
            <div class="grow panel" id="speaker-questions">questions</div>
        </div>
    </div>

    <div id="questions-panel" class="vbox">
        <div class="grow scroll" id="questions-view-wrapper">
            <div id="questions-view"></div>
        </div>
        <div id="questions-ask" class="hbox">
            <input  id="question-field" type="text" class="grow">
            <button id="question-button">send</button>
        </div>
    </div>

    <div id="speaker-notes-control" class="vbox">
        <button id="to-start">to start</button>
        <button id="to-left">to left</button>
        <button id="to-right">to right</button>
        <button id="to-end">to end</button>
    </div>


    <script type="text/javascript">
        //highlight the page with code in it
        function style() {
            var elems = document.querySelectorAll('pre');
            elems.forEach(function(elem){
                try {
                    hljs.highlightBlock(elem);
                } catch(e) {
                    console.log("error highlighting",e);
                }
            })
        }
         setTimeout(style,1000);


        try {
            document.querySelectorAll("section").forEach(function(sec,i) {
                var hammertime = new Hammer(sec);
                hammertime.on('tap', function(ev) {
                    slides.navRight();
                });
                hammertime.on('swiperight', function (ev) {
                    slides.navLeft();
                });
                hammertime.on('swipeleft', function (ev) {
                    slides.navRight();
                });
            })
        } catch (e) {
            console.log(e);
        }

    </script>
</body>
</html>
